esphome:
  name: a6v3
  friendly_name: a6v3
  libraries:
    - adafruit/Adafruit DS248x @ ^1.0.2
    - adafruit/Adafruit BusIO @ ^1.14.5
  platformio_options:
    lib_deps:
      - adafruit/Adafruit DS248x @ ^1.0.2
      - adafruit/Adafruit BusIO @ ^1.14.5
    lib_ldf_mode: deep+
    build_flags:
      - -I$PROJECT_PACKAGES_DIR/framework-arduinoespressif32/libraries/Wire/src
      - -I$PROJECT_PACKAGES_DIR/framework-arduinoespressif32/libraries/Network/src
  on_boot:
    priority: 600
    then:
      - lambda: |-
          id(mischer_schliesst) = false;
          id(mischer_geschlossen) = false;
          ESP_LOGI("Boot", "Mischer-Flags zurückgesetzt: schliesst=%d, geschlossen=%d", id(mischer_schliesst), id(mischer_geschlossen));
      - lambda: |-
          uint8_t buf[4];
          auto dev = id(eeprom);
          if (dev->read(buf, sizeof(buf)) == esphome::i2c::ErrorCode::ERROR_OK) {
            float val;
            memcpy(&val, buf, sizeof(val));
            if (std::isfinite(val) && val >= 0.0f && val < 100000.0f) {
              id(brenner_betriebsstunden) = val;
              ESP_LOGI("FRAM", "Brenner-Betriebsstunden geladen: %.2f h", val);
            }
          }
      - lambda: |-
          uint8_t buf[4];
          auto dev = id(eeprom);
          // Adresse 0x10 setzen und lesen
          uint8_t addr[2] = {0x00, 0x10}; // High, Low Byte
          if (dev->write(addr, 2) == esphome::i2c::ErrorCode::ERROR_OK &&
              dev->read(buf, sizeof(buf)) == esphome::i2c::ErrorCode::ERROR_OK) {
            float val;
            memcpy(&val, buf, sizeof(val));
            if (std::isfinite(val) && val >= 30.0f && val <= 80.0f) {
              id(warmwasser_zieltemperatur) = val;
              ESP_LOGI("FRAM", "Warmwasser-Zieltemperatur geladen: %.2f °C", val);
            }
          }
esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  password: ""
  services:
    - service: set_zieltemperatur
      variables:
        temp: float
      then:
        - lambda: |-
            id(zieltemperatur) = temp;
            id(pid_integral) = 0.0;
            id(pid_last_error) = 0.0;
            ESP_LOGI("PID", "Zieltemperatur gesetzt: %.2f, Integral und Last Error zurückgesetzt.", temp);

ota:
  platform: esphome
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:

web_server:
  port: 80
  auth:
    username: admin
    password: heizung123
  include_internal: true
  local: true
  css_include: webserver.css
  js_include: webserver.js
  
captive_portal:

external_components:
  - source:
      type: local
      path: ./components

i2c:
  sda: 12
  scl: 11
  scan: true
  id: bus_a

i2c_device:
  - id: eeprom
    address: 0x51

ds2482_custom:
  address: 0x18
  update_interval: 30s
  sensors:
    - channel: 0
      name: "Vorlauftemperatur"
      id: vorlauftemperatur
      accuracy_decimals: 2
      filters:
        - filter_out: nan
      on_value:
        then:
          - logger.log:
              format: "Vorlauftemperatur: %.2f C"
              args: [ 'x' ]
      on_raw_value:
      - logger.log: "Vorlauftemperatur Rohwert gelesen"             
    - channel: 1
      name: "Kesseltemperatur"
      id: kesseltemperatur
      accuracy_decimals: 2
      filters:
        - filter_out: nan
      on_value:
        then:
          - logger.log:
              format: "Kesseltemperatur: %.2f C"
              args: [ 'x' ]
      on_raw_value:
      - logger.log: "Kesseltemperatur Rohwert gelesen"
    - channel: 2
      name: "Warmwassertemperatur"
      id: warmwassertemperatur
      accuracy_decimals: 2
      filters:
        - filter_out: nan
      on_value:
        then:
          - logger.log:
              format: "Warmwassertemperatur: %.2f C"
              args: [ 'x' ]    
      on_raw_value:
      - logger.log: "Warmwassertemperatur Rohwert gelesen"        
    - channel: 3
      name: "Outdoor"
      id: outdoor
      accuracy_decimals: 2

# Example configuration entry
pcf8574:
  - id: 'pcf8574_hub_out_1'  # for output channel 1-8
    address: 0x24

  - id: 'pcf8574_hub_in_1'  # for input channel 1-8
    address: 0x22

uart:
  id: uart_nextion
  tx_pin: 13
  rx_pin: 14
  baud_rate: 115200

display:
  - platform: nextion
    id: nextion_display
    uart_id: uart_nextion
    lambda: |-
      it.set_component_text("t_title", "HEIZUNG");
    # Serve the TFT from HA (http or https). http is faster on small MCUs.
    tft_url: http://192.168.1.56:8123/local/tft/heizung.tft
    # optional: choose a page at connect
    start_up_page: 0


globals:
  - id: zieltemperatur
    type: float
    restore_value: true
    initial_value: '40.0'
  - id: letzte_aktion
    type: unsigned long
    restore_value: true
    initial_value: '0'
  - id: letzter_status
    type: int
    restore_value: true
    initial_value: '0'
  - id: impulsdauer_ms
    type: int
    restore_value: true
    initial_value: '1500'
  - id: impuls_pause_ms
    type: int
    restore_value: true
    initial_value: '30000'
  - id: letzte_temp
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: pid_integral
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: pid_last_error
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: pid_output
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: pid_kp
    type: float
    restore_value: true
    initial_value: '1.2'
  - id: pid_ki
    type: float
    restore_value: true
    initial_value: '0.005'
  - id: pid_kd
    type: float
    restore_value: true
    initial_value: '0.3'
  - id: warmwasser_zieltemperatur
    type: float
    restore_value: true
    initial_value: '50.0'
  - id: heizmodus
    type: std::string
    restore_value: true
    initial_value: '"summer"'
  - id: mischer_position
    type: float
    restore_value: true
    initial_value: '50.0'
  - id: mischer_laufzeit_s
    type: int
    restore_value: true
    initial_value: '120'
  - id: letzte_kalibrierung
    type: unsigned long
    restore_value: true
    initial_value: '0'
  - id: mischer_schliesst
    type: bool
    restore_value: true
    initial_value: 'false'
  - id: mischer_geschlossen
    type: bool
    restore_value: true
    initial_value: 'false'
  - id: invalid_sensor_count
    type: int
    restore_value: true
    initial_value: '0'
  - id: warmwasser_zieltemperatur_backup
    type: float
    restore_value: false
    initial_value: '50.0'
  - id: brenner_betriebsstunden
    type: float
    restore_value: true
    initial_value: '0.0'

select:
  - platform: template
    name: "Heizmodus"
    id: heizmodus_select
    optimistic: true
    options:
      - "summer"
      - "winter"
      - "pool"
    initial_option: "summer"
    on_value:
      then:
        - lambda: |-
            id(heizmodus) = x;
            ESP_LOGI("Heizmodus", "Heizmodus geändert auf: %s", x.c_str());
            if (x == "summer" || x == "pool") {
              id(heizkreispumpe).turn_off();
              id(mischer_auf).turn_off();
              id(mischer_zu).turn_off();
              id(letzter_status) = 0;
              if (!id(mischer_schliesst) && !id(mischer_geschlossen)) {
                id(schliesse_mischer_komplett).execute();
                ESP_LOGI("Heizmodus", "%s-Modus: Mischer wird komplett geschlossen", x.c_str());
              }
              if (x == "pool") {
                id(warmwasserpumpe).turn_off();
                ESP_LOGI("Heizmodus", "Pool-Modus: Warmwasserpumpe deaktiviert");
              }
            } else {
              id(mischer_geschlossen) = false;
              ESP_LOGI("Heizmodus", "Winter-Modus: Mischer-Geschlossen-Flag zurückgesetzt");
            }


# Individual outputs
switch:
  - platform: gpio
    name: "a6-light1"
    id: light1
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 0
      mode: OUTPUT
      inverted: true

  - platform: gpio
    name: "Mischer Auf"
    id: mischer_auf
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 1
      mode: OUTPUT
      inverted: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - logger.log: "Mischer Auf wird EIN geschaltet"
    on_turn_off:
      - logger.log: "Mischer Auf wird AUS geschaltet"  
  - platform: gpio
    name: "Mischer Zu"
    id: mischer_zu
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 2
      mode: OUTPUT
      inverted: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - logger.log: "Mischer Zu wird EIN geschaltet"
    on_turn_off:
      - logger.log: "Mischer Zu wird AUS geschaltet"   
  - platform: gpio
    name: "Heizkreispumpe"
    id: heizkreispumpe
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 3
      mode: OUTPUT
      inverted: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - logger.log: "Heizkreispumpe wird EIN geschaltet"
    on_turn_off:
      - logger.log: "Heizkreispumpe wird AUS geschaltet" 
  - platform: gpio
    name: "Warmwasserpumpe"
    id: warmwasserpumpe
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 4
      mode: OUTPUT
      inverted: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - logger.log: "Warmwasserpumpe wird EIN geschaltet"
    on_turn_off:
      - logger.log: "Warmwasserpumpe wird AUS geschaltet" 
  - platform: gpio
    name: "Brenner"
    id: brenner
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 5
      mode: OUTPUT
      inverted: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - logger.log: "Brenner wird EIN geschaltet"
    on_turn_off:
      - logger.log: "Brenner wird AUS geschaltet"  
  - platform: template
    name: "Legionellenschaltung aktiv"
    id: legionellen_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON  # Standard: aktiv nach Neustart     

binary_sensor:
  - platform: gpio
    name: "a6-input1"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 0
      mode: INPUT
      inverted: true

  - platform: gpio
    name: "a6-input2"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 1
      mode: INPUT
      inverted: true

  - platform: gpio
    name: "a6-input3"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 2
      mode: INPUT
      inverted: true

  - platform: gpio
    name: "Brennerbetrieb BZ"
    id: brennerbetrieb_bz
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 3
      mode: INPUT
      inverted: true
    device_class: running

  - platform: gpio
    name: "Brennerstoerung"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 4
      mode: INPUT
      inverted: true

  - platform: gpio
    name: "Thermostat_Buderus"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 5
      mode: INPUT
      inverted: true

script:
  - id: pulsiere_mischer_auf
    mode: restart
    then:
      - logger.log: "Impuls: Mischer AUF"
      - switch.turn_on: mischer_auf
      - delay: !lambda 'return id(impulsdauer_ms);'
      - switch.turn_off: mischer_auf
      - lambda: |-
          float position_change = static_cast<float>(id(impulsdauer_ms)) / 1000.0 / id(mischer_laufzeit_s) * 100.0;
          id(mischer_position) += position_change;
          if (id(mischer_position) > 100.0) id(mischer_position) = 100.0;
          id(mischer_geschlossen) = false;
          ESP_LOGI("Mischer", "Position aktualisiert: %.1f%% (AUF)", id(mischer_position));
  - id: pulsiere_mischer_zu
    mode: restart
    then:
      - logger.log: "Impuls: Mischer ZU"
      - switch.turn_on: mischer_zu
      - delay: !lambda 'return id(impulsdauer_ms);'
      - switch.turn_off: mischer_zu
      - lambda: |-
          float position_change = static_cast<float>(id(impulsdauer_ms)) / 1000.0 / id(mischer_laufzeit_s) * 100.0;
          id(mischer_position) -= position_change;
          if (id(mischer_position) < 0.0) id(mischer_position) = 0.0;
          ESP_LOGI("Mischer", "Position aktualisiert: %.1f%% (ZU)", id(mischer_position));
  - id: kalibriere_mischer
    mode: restart
    then:
      - logger.log: "Kalibrierung: Mischer wird vollständig geschlossen und geöffnet"
      - switch.turn_on: mischer_zu
      - delay: !lambda 'return id(mischer_laufzeit_s) * 1000;'
      - switch.turn_off: mischer_zu
      - lambda: |-
          id(mischer_position) = 0.0;
          id(mischer_geschlossen) = true;
          ESP_LOGI("Mischer", "Kalibrierung: Geschlossen, Position: %.1f%%", id(mischer_position));
      - switch.turn_on: mischer_auf
      - delay: !lambda 'return id(mischer_laufzeit_s) * 1000;'
      - switch.turn_off: mischer_auf
      - lambda: |-
          id(mischer_position) = 100.0;
          id(letzte_kalibrierung) = millis();
          id(mischer_geschlossen) = false;
          ESP_LOGI("Mischer", "Kalibrierung abgeschlossen, Position: %.1f%%", id(mischer_position));
  - id: schliesse_mischer_komplett
    mode: restart
    then:
      - lambda: |-
          if (id(mischer_schliesst)) {
            ESP_LOGI("Mischer", "Schließen bereits im Gange, Skript abgebrochen");
            return;
          }
          if (id(mischer_geschlossen)) {
            ESP_LOGI("Mischer", "Mischer bereits geschlossen (Position %.1f%%), Skript abgebrochen", id(mischer_position));
            return;
          }
          id(mischer_schliesst) = true;
      - logger.log: "Mischer wird komplett geschlossen"
      - logger.log: "Mischer Zu wird EIN geschaltet"
      - switch.turn_on: mischer_zu
      - delay: !lambda 'return id(mischer_laufzeit_s) * 1000;'
      - switch.turn_off: mischer_zu
      - logger.log: "Mischer Zu wird AUS geschaltet"
      - lambda: |-
          id(mischer_position) = 0.0;
          id(letzter_status) = 0;
          id(mischer_schliesst) = false;
          id(mischer_geschlossen) = true;
          ESP_LOGI("Mischer", "Mischer komplett geschlossen: Position auf 0%% gesetzt");
          if (id(mischer_position_sensor).has_state()) {
            id(mischer_position_sensor).publish_state(id(mischer_position));
          } else {
            ESP_LOGW("Mischer", "Sensor hat keinen Status, Position %.1f%% konnte nicht gesendet werden", id(mischer_position));
          }



button:
  - platform: template
    id: update_nextion_button
    name: "Update Nextion"
    entity_category: diagnostic
    on_press:
      then:
        - lambda: 'id(nextion_display)->upload_tft();'
  - platform: template
    name: "EEPROM Self-Test"
    id: eeprom_self_test
    on_press:
      - lambda: |-
          using esphome::i2c::ErrorCode;

          auto dev = id(eeprom);
          const uint16_t base = 0x7FF0;
          const uint8_t  N    = 16;
          uint8_t original[N], verify[N];

          auto wr = [&](uint16_t addr, uint8_t val) -> bool {
            uint8_t buf[3] = { (uint8_t)(addr >> 8), (uint8_t)(addr & 0xFF), val };
            auto res = dev->write(buf, sizeof(buf));
            delay(5);  // tWR
            return res == ErrorCode::ERROR_OK;
          };

          auto rd = [&](uint16_t addr, uint8_t *out) -> bool {
            uint8_t ab[2] = { (uint8_t)(addr >> 8), (uint8_t)(addr & 0xFF) };
            if (dev->write(ab, sizeof(ab)) != ErrorCode::ERROR_OK) return false;
            return dev->read(out, 1) == ErrorCode::ERROR_OK;
          };

          ESP_LOGI("eeprom", "Starting self-test at 0x%04X..0x%04X", base, base + N - 1);

          for (uint8_t i = 0; i < N; i++) {
            if (!rd(base + i, &original[i])) {
              ESP_LOGE("eeprom", "Read original failed @0x%04X", base + i);
              return;
            }
          }

          for (uint8_t i = 0; i < N; i++) {
            uint8_t v = 0xA0 + i;
            if (!wr(base + i, v)) {
              ESP_LOGE("eeprom", "Write failed @0x%04X", base + i);
              for (uint8_t j = 0; j <= i; j++) wr(base + j, original[j]);
              return;
            }
          }

          uint8_t mismatches = 0;
          for (uint8_t i = 0; i < N; i++) {
            if (!rd(base + i, &verify[i])) { mismatches = 0xFF; break; }
            uint8_t exp = 0xA0 + i;
            if (verify[i] != exp) {
              ESP_LOGE("eeprom", "Mismatch @0x%04X: got 0x%02X, expected 0x%02X", base + i, verify[i], exp);
              mismatches++;
            }
          }

          for (uint8_t i = 0; i < N; i++) wr(base + i, original[i]);

          if (mismatches == 0) {
            ESP_LOGI("eeprom", "EEPROM self-test PASS (restored).");
          } else if (mismatches == 0xFF) {
            ESP_LOGE("eeprom", "EEPROM self-test FAILED due to read error (restored).");
          } else {
            ESP_LOGE("eeprom", "EEPROM self-test FAILED with %u mismatches (restored).", mismatches);
          }
  - platform: restart
    name: "Neustart"
    id: restart_button
  - platform: template
    name: "Reset Alle Einstellungen"
    id: reset_all_settings
    icon: "mdi:restart"
    on_press:
      then:
        - lambda: |-
            id(zieltemperatur) = 40.0f;
            id(letzte_aktion) = 0UL;
            id(letzter_status) = 0;
            id(impulsdauer_ms) = 1500;
            id(impuls_pause_ms) = 30000;
            id(letzte_temp) = 0.0f;
            id(pid_integral) = 0.0f;
            id(pid_last_error) = 0.0f;
            id(pid_output) = 0.0f;
            id(pid_kp) = 1.2f;
            id(pid_ki) = 0.005f;
            id(pid_kd) = 0.3f;
            id(warmwasser_zieltemperatur) = 50.0f;
            id(heizmodus) = "summer";
            id(mischer_position) = 50.0f;
            id(mischer_laufzeit_s) = 120;
            id(letzte_kalibrierung) = 0UL;
            id(mischer_schliesst) = false;
            id(mischer_geschlossen) = false;
            id(invalid_sensor_count) = 0;
            ESP_LOGI("Reset", "Alle nichtflüchtigen Einstellungen wurden auf Standardwerte zurückgesetzt.");
        - button.press: restart_button


sensor:
  - platform: wifi_signal
    name: "Heizung ESP32 WLAN Qualität"
    update_interval: 60s
    unit_of_measurement: "%"
    accuracy_decimals: 0
    filters:
      - lambda: |-
          int rssi = static_cast<int>(x);
          if (rssi <= -100) return 0;
          else if (rssi >= -50) return 100;
          else return 2 * (rssi + 100);
  - platform: template
    name: "Vorlauftemperatur 30min Mittelwert"
    id: vorlauf_30min_mittel
    unit_of_measurement: "C"
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      return id(vorlauftemperatur).state;
    filters:
      - sliding_window_moving_average:
          window_size: 180
          send_every: 1
  - platform: template
    name: "Zieltemperatur Sensor"
    id: zieltemperatur_sensor
    unit_of_measurement: "C"
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      return id(zieltemperatur);
  - platform: template
    name: "Warmwasser Zieltemperatur Sensor"
    id: warmwasser_zieltemperatur_sensor
    unit_of_measurement: "C"
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      return id(warmwasser_zieltemperatur);
  - platform: template
    name: "Mischer Position"
    id: mischer_position_sensor
    unit_of_measurement: "%"
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      return id(mischer_position);

  - platform: uptime
    name: "ESPHome Laufzeit Sekunden"
    id: esphome_uptime_seconds
  - platform: template
    name: "Brenner Betriebsstunden"
    id: brenner_betriebsstunden_sensor
    unit_of_measurement: "h"
    accuracy_decimals: 2
    lambda: |-
      return id(brenner_betriebsstunden);
    update_interval: 60s

text_sensor:
  - platform: template
    name: "ESPHome Laufzeit formatiert"
    lambda: |-
      uint32_t seconds = (uint32_t) id(esphome_uptime_seconds).state;
      uint32_t days = seconds / 86400;
      uint32_t hours = (seconds % 86400) / 3600;
      uint32_t minutes = (seconds % 3600) / 60;
      uint32_t secs = seconds % 60;
      char buf[32];
      snprintf(buf, sizeof(buf), "%ud %02uh %02um %02us", days, hours, minutes, secs);
      return std::string(buf);
    update_interval: 60s
    icon: mdi:clock-outline

number:
  - platform: template
    name: "Zieltemperatur"
    id: zieltemperatur_input
    optimistic: true
    min_value: 20.0
    max_value: 60.0
    step: 0.5
    initial_value: 40.0
    set_action:
      then:
        - lambda: |-
            id(zieltemperatur) = x;
            id(pid_integral) = 0.0;
            id(pid_last_error) = 0.0;
            ESP_LOGI("PID", "Zieltemperatur über UI gesetzt: %.2f", x);
  - platform: template
    name: "Warmwasser Zieltemperatur"
    id: warmwasser_zieltemperatur_input
    optimistic: true
    min_value: 30.0
    max_value: 60.0
    step: 1.0
    initial_value: 50.0
    set_action:
      then:
        - lambda: |-
            id(warmwasser_zieltemperatur) = x;
            ESP_LOGI("Warmwasser", "Warmwasser-Zieltemperatur über UI gesetzt: %.2f", x);
  - platform: template
    name: "Mischer Laufzeit"
    id: mischer_laufzeit_input
    optimistic: true
    min_value: 60
    max_value: 300
    step: 1
    initial_value: 120
    unit_of_measurement: "s"
    set_action:
      then:
        - lambda: |-
            id(mischer_laufzeit_s) = x;
            ESP_LOGI("Mischer", "Mischer Laufzeit über UI gesetzt: %d s", x);

time:
  - platform: sntp
    id: sntp_time
    on_time:
      - seconds: 0
        minutes: 0
        hours: 2
        days_of_week: 7  # 7=Sonntag
        then:
          - if:
              condition:
                switch.is_on: legionellen_enable
              then:
                - lambda: |-
                    id(warmwasser_zieltemperatur_backup) = id(warmwasser_zieltemperatur); // Backup aktuelle Temperatur
                    id(warmwasser_zieltemperatur) = 70.0f;
                    id(warmwasser_zieltemperatur_input).publish_state(70.0f);
                    ESP_LOGI("Legionellen", "Legionellen-Schaltung gestartet: Warmwasser-Zieltemperatur auf 70°C gesetzt (Backup: %.1f°C)", id(warmwasser_zieltemperatur_backup));
                - delay: 3h
                - lambda: |-
                    id(warmwasser_zieltemperatur) = id(warmwasser_zieltemperatur_backup); // Wiederherstellen
                    id(warmwasser_zieltemperatur_input).publish_state(id(warmwasser_zieltemperatur_backup));
                    ESP_LOGI("Legionellen", "Legionellen-Schaltung beendet: Warmwasser-Zieltemperatur zurück auf %.1f°C", id(warmwasser_zieltemperatur_backup));

interval:
  - interval: 30s
    then:
      - lambda: |-
          if (!std::isfinite(id(kesseltemperatur).state) || !std::isfinite(id(warmwassertemperatur).state) ||
              !std::isfinite(id(vorlauftemperatur).state)) {
            ESP_LOGW("Control", "Ungültige Sensorwerte: Kessel=%.2f, Warmwasser=%.2f, Vorlauf=%.2f",
                     id(kesseltemperatur).state, id(warmwassertemperatur).state, id(vorlauftemperatur).state);
            id(invalid_sensor_count)++;
            if (id(invalid_sensor_count) >= 3) {
              id(warmwasserpumpe).turn_off();
              id(brenner).turn_off();
              id(heizkreispumpe).turn_off();
              id(mischer_auf).turn_off();
              id(mischer_zu).turn_off();
              id(letzter_status) = 0;
              if (!id(mischer_schliesst) && !id(mischer_geschlossen)) {
                id(schliesse_mischer_komplett).execute();
                ESP_LOGI("Control", "Sicherheitsabschaltung: Mischer wird komplett geschlossen");
              }
              id(invalid_sensor_count) = 0;
            }
            return;
          }
          id(invalid_sensor_count) = 0;

          unsigned long jetzt = millis();
          const unsigned long kalibrier_intervall_ms = 24UL * 60UL * 60UL * 1000UL;
          if (jetzt - id(letzte_kalibrierung) > kalibrier_intervall_ms) {
            id(kalibriere_mischer).execute();
            ESP_LOGI("Mischer", "Kalibrierung gestartet: Zeit seit letzter Kalibrierung > 24h");
          }

          ESP_LOGD("Control", "Heizmodus: %s, Mischer schliesst: %d, Mischer geschlossen: %d",
                   id(heizmodus).c_str(), id(mischer_schliesst), id(mischer_geschlossen));
          if (id(heizmodus) == "summer") {
            id(heizkreispumpe).turn_off();
            id(mischer_auf).turn_off();
            id(mischer_zu).turn_off();
            id(letzter_status) = 0;
            if (!id(mischer_schliesst) && !id(mischer_geschlossen)) {
              id(schliesse_mischer_komplett).execute();
              ESP_LOGI("Heizmodus", "Sommermodus: Mischer wird komplett geschlossen");
            }
          } else if (id(heizmodus) == "pool") {
            id(heizkreispumpe).turn_off();
            id(warmwasserpumpe).turn_off();
            id(mischer_auf).turn_off();
            id(mischer_zu).turn_off();
            id(letzter_status) = 0;
            if (!id(mischer_schliesst) && !id(mischer_geschlossen)) {
              id(schliesse_mischer_komplett).execute();
              ESP_LOGI("Heizmodus", "Poolmodus: Mischer wird komplett geschlossen");
            }
          } else {
            float vorlauf_soll = id(zieltemperatur);
            float vorlauf_ist = id(vorlauftemperatur).state;
            const float hysterese = 2.0;
            if (vorlauf_ist < vorlauf_soll - hysterese && id(kesseltemperatur).state >= 40.0) {
              id(heizkreispumpe).turn_on();
              ESP_LOGI("Heizkreis", "Pumpe EIN: Vorlauf=%.2f C, Soll=%.2f C, Kessel=%.2f C",
                       vorlauf_ist, vorlauf_soll, id(kesseltemperatur).state);
            } else if (vorlauf_ist >= vorlauf_soll || id(kesseltemperatur).state < 38.0) {
              id(heizkreispumpe).turn_off();
              ESP_LOGI("Heizkreis", "Pumpe AUS: Vorlauf=%.2f C, Soll=%.2f C, Kessel=%.2f C",
                       vorlauf_ist, vorlauf_soll, id(kesseltemperatur).state);
            }

            if (id(heizkreispumpe).state) {
              float soll = id(zieltemperatur);
              float ist = id(vorlauftemperatur).state;
              float dt = 30.0;
              float error = soll - ist;

              id(pid_integral) += error * dt;
              if (id(pid_integral) > 100.0) id(pid_integral) = 100.0;
              if (id(pid_integral) < -100.0) id(pid_integral) = -100.0;

              float derivative = (error - id(pid_last_error)) / dt;
              id(pid_last_error) = error;

              float output = (id(pid_kp) * error) +
                             (id(pid_ki) * id(pid_integral)) +
                             (id(pid_kd) * derivative);

              if (!std::isfinite(output)) {
                ESP_LOGW("PID", "Ungültiger Output: NaN erkannt");
                output = 0.0;
              }

              id(pid_output) = output;

              const float impuls_schwelle = 1.0;
              unsigned long jetzt = millis();

              if (jetzt - id(letzte_aktion) > id(impuls_pause_ms)) {
                if (output > impuls_schwelle) {
                  id(pulsiere_mischer_auf).execute();
                  id(letzte_aktion) = jetzt;
                  id(letzter_status) = 1;
                  ESP_LOGI("Mischer", "PID: Mischer AUF, Output=%.2f", output);
                } else if (output < -impuls_schwelle) {
                  id(pulsiere_mischer_zu).execute();
                  id(letzte_aktion) = jetzt;
                  id(letzter_status) = 2;
                  ESP_LOGI("Mischer", "PID: Mischer ZU, Output=%.2f", output);
                } else {
                  id(mischer_auf).turn_off();
                  id(mischer_zu).turn_off();
                  id(letzter_status) = 0;
                }
              }
            } else {
              if (!id(mischer_schliesst) && !id(mischer_geschlossen)) {
                id(schliesse_mischer_komplett).execute();
                ESP_LOGI("Mischer", "Heizkreispumpe aus: Mischer wird komplett geschlossen");
              }
            }
          }

          float warmwasser_soll = id(warmwasser_zieltemperatur);
          float warmwasser_ist = id(warmwassertemperatur).state;
          float kessel_temp = id(kesseltemperatur).state;
          const float hysterese = 2.0;
          const float kessel_min_temp = 55.0;
          const float kessel_min_hysterese = 2.0;

          if (id(heizmodus) != "pool") {
            if (warmwasser_ist < warmwasser_soll - hysterese && kessel_temp > warmwasser_ist && (kessel_temp >= kessel_min_temp || id(brenner).state)) {
              id(warmwasserpumpe).turn_on();
              ESP_LOGI("Warmwasser", "Pumpe EIN: Warmwasser=%.2f C, Soll=%.2f C, Kessel=%.2f C, Brenner=%s",
                       warmwasser_ist, warmwasser_soll, kessel_temp, id(brenner).state ? "AN" : "AUS");
            } else if (warmwasser_ist >= warmwasser_soll || kessel_temp <= warmwasser_ist || kessel_temp < kessel_min_temp - kessel_min_hysterese) {
              id(warmwasserpumpe).turn_off();
              ESP_LOGI("Warmwasser", "Pumpe AUS: Warmwasser=%.2f C, Soll=%.2f C, Kessel=%.2f C, Brenner=%s",
                       warmwasser_ist, warmwasser_soll, kessel_temp, id(brenner).state ? "AN" : "AUS");
            }
          }

          float kessel_soll;
          if (id(heizmodus) == "summer") {
            if (warmwasser_ist < warmwasser_soll - hysterese) {
              kessel_soll = 65.0;
              ESP_LOGI("Brenner", "Sommermodus (Warmwasser): Kessel-Soll auf 65 C gesetzt");
            } else {
              kessel_soll = 40.0;
              ESP_LOGI("Brenner", "Sommermodus: Kessel-Soll auf 40 C gesetzt");
            }
          } else if (id(heizmodus) == "pool") {
            kessel_soll = 80.0;
            ESP_LOGI("Brenner", "Poolmodus: Kessel-Soll auf 80 C gesetzt");
          } else {
            kessel_soll = 65.0;
            ESP_LOGI("Brenner", "Wintermodus: Kessel-Soll auf 65 C gesetzt");
          }

          if (kessel_temp < kessel_soll - hysterese) {
            id(brenner).turn_on();
            ESP_LOGI("Brenner", "EIN: Kessel=%.2f C, Soll=%.2f C, Modus=%s",
                     kessel_temp, kessel_soll, id(heizmodus).c_str());
          } else if (kessel_temp >= kessel_soll) {
            id(brenner).turn_off();
            ESP_LOGI("Brenner", "AUS: Kessel=%.2f C, Soll=%.2f C, Modus=%s",
                     kessel_temp, kessel_soll, id(heizmodus).c_str());
          }
  - interval: 1min
    then:
      - if:
          condition:
            binary_sensor.is_on: brennerbetrieb_bz
          then:
            - lambda: |-
                id(brenner_betriebsstunden) += 1.0 / 60.0;  // 1 Minute = 1/60 Stunde
      - lambda: |-
          float val = id(brenner_betriebsstunden);
          uint8_t buf[4];
          memcpy(buf, &val, sizeof(val));
          auto dev = id(eeprom);
          dev->write(buf, sizeof(buf));
          ESP_LOGD("FRAM", "Brenner-Betriebsstunden gespeichert: %.2f h", val);
      - lambda: |-
          float val = id(warmwasser_zieltemperatur);
          uint8_t buf[4];
          memcpy(buf, &val, sizeof(val));
          auto dev = id(eeprom);
          uint8_t addr[2] = {0x00, 0x10}; // High, Low Byte
          if (dev->write(addr, 2) == esphome::i2c::ErrorCode::ERROR_OK &&
              dev->write(buf, sizeof(buf)) == esphome::i2c::ErrorCode::ERROR_OK) {
            ESP_LOGD("FRAM", "Warmwasser-Zieltemperatur gespeichert: %.2f °C", val);
          }
  - interval: 1s
    then:
      - lambda: |-

          // Clock (HH:MM)
          if (id(sntp_time).now().is_valid()) {
            char tbuf[6];
            snprintf(tbuf, sizeof(tbuf), "%02d:%02d", id(sntp_time).now().hour, id(sntp_time).now().minute);
            id(nextion_display).set_component_text("home.t_time", tbuf);
          }
          // small helper to print temperatures safely
          auto print_temp = [&](const char* comp, float v) {
            if (!std::isfinite(v)) {
              id(nextion_display).set_component_text(comp, "--");
              return;
            }
            char buf[16];
            snprintf(buf, sizeof(buf), "%.1f°C", v);
            id(nextion_display).set_component_text(comp, buf);
          };
          // --- HOME page values ---
          print_temp("home.t_flow", id(vorlauftemperatur).state);
          print_temp("home.t_out",  id(outdoor).state);

          // Vorlauf-Soll (use your GLOBAL 'zieltemperatur' or the number entity)
          {
            char buf[16];
            // If you want the GLOBAL:
            snprintf(buf, sizeof(buf), "%.1f°C", id(zieltemperatur));
            // If you prefer the NUMBER entity instead, use this line:
            // snprintf(buf, sizeof(buf), "%.1f°C", id(zieltemperatur_input).state);
            id(nextion_display).set_component_text("home.t_flow_sp", buf);
          }
          print_temp("home.t_boiler",  id(kesseltemperatur).state);
          print_temp("home.t_dhw",  id(warmwassertemperatur).state);
          // --- HOME page ---

#          id(nextion_display).set_component_text("page0.t_flow",     fmt(id(vorlauftemperatur).state).c_str());
#          id(nextion_display).set_component_text("page0.t_ou",      fmt(id(outdoor).state).c_str());
#          id(nextion_display).set_component_text("page0.t_flow_sp",  (to_string(id(zieltemperatur_input).state,1) + "°C").c_str());
#          id(hmi).set_component_text("home.t_boiler",   fmt(id(temp_boiler).state).c_str());
#          id(hmi).set_component_text("home.t_boiler_sp",(to_string(id(sp_boiler).state,1) + "°C").c_str());
#          id(hmi).set_component_text("home.t_dhw",      fmt(id(temp_dhw).state).c_str());
#          id(hmi).set_component_text("home.t_dhw_sp",   (to_string(id(sp_dhw).state,1) + "°C").c_str());
#          id(hmi).set_component_text("home.t_mode",     id(hvac_mode).state.c_str());

#          // j_mixer (optional if you have feedback)
#          // id(hmi).set_component_value("home.j_mixer", (int) round(id(mixer_pos).state * 100.0)); // 0..100



#          // --- HEATING page ---
#          id(hmi).set_component_text("heating.t_flow",     fmt(id(temp_flow).state).c_str());
#          id(hmi).set_component_text("heating.t_return",   fmt(id(temp_return).state).c_str());
#          id(hmi).set_component_text("heating.t_flow_sp",  (to_string(id(sp_flow).state,1) + "°C").c_str());
#          id(hmi).set_component_value("heating.n_curve_slope", (int) round(id(curve_slope).state * 10)); // x10
#          id(hmi).set_component_value("heating.n_curve_level", (int) id(curve_level).state);

 #         // --- DHW page ---
 #         id(hmi).set_component_text("dhw.t_dhw",    fmt(id(temp_dhw).state).c_str());
 #         id(hmi).set_component_text("dhw.t_dhw_sp", (to_string(id(sp_dhw).state,1) + "°C").c_str());

  #        // --- BOILER page ---
  #        id(hmi).set_component_text("boiler.t_boiler",    fmt(id(temp_boiler).state).c_str());
  #        id(hmi).set_component_text("boiler.t_boiler_sp", (to_string(id(sp_boiler).state,1) + "°C").c_str());