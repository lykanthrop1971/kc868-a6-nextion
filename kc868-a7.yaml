esphome:
  name: a6v3
  friendly_name: a6v3
  libraries:
    - adafruit/Adafruit DS248x @ ^1.0.2
    - adafruit/Adafruit BusIO @ ^1.14.5
  platformio_options:
    lib_deps:
      - adafruit/Adafruit DS248x @ ^1.0.2
      - adafruit/Adafruit BusIO @ ^1.14.5
    lib_ldf_mode: deep+
    build_flags:
      - -I$PROJECT_PACKAGES_DIR/framework-arduinoespressif32/libraries/Wire/src
      - -I$PROJECT_PACKAGES_DIR/framework-arduinoespressif32/libraries/Network/src
  on_boot:
    priority: -100
    then:
      - button.press: eeprom_self_test

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino


# Enable logging
logger:
  level: DEBUG
# Enable Home Assistant API
api:

ota:
  platform: esphome
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:

captive_portal:

external_components:
  - source:
      type: local
      path: ./components

i2c:
  sda: 12
  scl: 11
  scan: true
  id: bus_a

i2c_device:
  - id: eeprom
    address: 0x51


ds2482_custom:
  address: 0x18
  update_interval: 30s
  sensors:
    - channel: 0
      name: "Flow"
      accuracy_decimals: 2
    - channel: 4
      name: "Return"
      accuracy_decimals: 2
    - channel: 7
      name: "Outdoor"
      accuracy_decimals: 2


# Example configuration entry
pcf8574:
  - id: 'pcf8574_hub_out_1'  # for output channel 1-8
    address: 0x24

  - id: 'pcf8574_hub_in_1'  # for input channel 1-8
    address: 0x22

# Individual outputs
switch:
  - platform: gpio
    name: "a6-light1"
    id: light1
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 0
      mode: OUTPUT
      inverted: true

  - platform: gpio
    name: "a6-light2"
    id: light2
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 1
      mode: OUTPUT
      inverted: true
     
  - platform: gpio
    name: "a6-light3"
    id: light3
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 2
      mode: OUTPUT
      inverted: true
     
  - platform: gpio
    name: "a6-light4"
    id: light4
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 3
      mode: OUTPUT
      inverted: true
     
  - platform: gpio
    name: "a6-light5"
    id: light5
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 4
      mode: OUTPUT
      inverted: true
     
  - platform: gpio
    name: "a6-light6"
    id: light6
    pin:
      pcf8574: pcf8574_hub_out_1
      number: 5
      mode: OUTPUT
      inverted: true
     

binary_sensor:
  - platform: gpio
    name: "a6-input1"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 0
      mode: INPUT
      inverted: true

  - platform: gpio
    name: "a6-input2"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 1
      mode: INPUT
      inverted: true

  - platform: gpio
    name: "a6-input3"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 2
      mode: INPUT
      inverted: true

  - platform: gpio
    name: "a6-input4"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 3
      mode: INPUT
      inverted: true

  - platform: gpio
    name: "a6-input5"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 4
      mode: INPUT
      inverted: true

  - platform: gpio
    name: "a6-input6"
    pin:
      pcf8574: pcf8574_hub_in_1
      number: 5
      mode: INPUT
      inverted: true
button:
  - platform: template
    name: "EEPROM Self-Test"
    id: eeprom_self_test
    on_press:
      - lambda: |-
          using esphome::i2c::ErrorCode;

          auto dev = id(eeprom);
          const uint16_t base = 0x7FF0;
          const uint8_t  N    = 16;
          uint8_t original[N], verify[N];

          auto wr = [&](uint16_t addr, uint8_t val) -> bool {
            uint8_t buf[3] = { (uint8_t)(addr >> 8), (uint8_t)(addr & 0xFF), val };
            auto res = dev->write(buf, sizeof(buf));
            delay(5);  // tWR
            return res == ErrorCode::ERROR_OK;
          };

          auto rd = [&](uint16_t addr, uint8_t *out) -> bool {
            uint8_t ab[2] = { (uint8_t)(addr >> 8), (uint8_t)(addr & 0xFF) };
            if (dev->write(ab, sizeof(ab)) != ErrorCode::ERROR_OK) return false;
            return dev->read(out, 1) == ErrorCode::ERROR_OK;
          };

          ESP_LOGI("eeprom", "Starting self-test at 0x%04X..0x%04X", base, base + N - 1);

          for (uint8_t i = 0; i < N; i++) {
            if (!rd(base + i, &original[i])) {
              ESP_LOGE("eeprom", "Read original failed @0x%04X", base + i);
              return;
            }
          }

          for (uint8_t i = 0; i < N; i++) {
            uint8_t v = 0xA0 + i;
            if (!wr(base + i, v)) {
              ESP_LOGE("eeprom", "Write failed @0x%04X", base + i);
              for (uint8_t j = 0; j <= i; j++) wr(base + j, original[j]);
              return;
            }
          }

          uint8_t mismatches = 0;
          for (uint8_t i = 0; i < N; i++) {
            if (!rd(base + i, &verify[i])) { mismatches = 0xFF; break; }
            uint8_t exp = 0xA0 + i;
            if (verify[i] != exp) {
              ESP_LOGE("eeprom", "Mismatch @0x%04X: got 0x%02X, expected 0x%02X", base + i, verify[i], exp);
              mismatches++;
            }
          }

          for (uint8_t i = 0; i < N; i++) wr(base + i, original[i]);

          if (mismatches == 0) {
            ESP_LOGI("eeprom", "EEPROM self-test PASS (restored).");
          } else if (mismatches == 0xFF) {
            ESP_LOGE("eeprom", "EEPROM self-test FAILED due to read error (restored).");
          } else {
            ESP_LOGE("eeprom", "EEPROM self-test FAILED with %u mismatches (restored).", mismatches);
          }